[report.md](https://github.com/user-attachments/files/23570571/report.md)
# Отчёт по задаче A3

Рабинович Майя, id:
349327754  
[Мой репозиторий на GitHub](https://github.com/293mya/Set3)



## 1. Описание подхода

В работе сравнивались две сортировки:

- `quick_sort`  реализация быстрой сортировки из задания A3i  
- `intro_sort` гибридная сортировка (Quick Sort + Heap Sort при глубокой рекурсии)

Для того что бы их сравнить надо было:

- Генерировались три типа массивов:`random`,`reversed`,`almost_sorted`
- Размер массива менялся от 500 до 10000 элементов (шаг 100)
- Для каждого размера делалась копия массива и сортировалась обоими алгоритмами
- Время измерялось с помощью `std::chrono::high_resolution_clock`
- Все результаты сохранили в CSV
- На основе CSV построили графики на Python


## 2. Сравнительный анализ

### 2.1 Почти отсортированные массивы

![almost_sorted](almost_sorted.png)

Из гафика видно: 
На почти отсортированных массивах гибридная сортировка работает заметно быстрее. Её график растёт ровно и плавно, без резких скачков. Quick Sort работает медленнее и менее стабильно.


### 2.2 Случайные массивы

![random](random.png)

Из гафика видно:
На случайных массивах оба алгоритма показывают близкое время работы. Quick Sort немного быстрее на большинстве точек, но разница не критичная. Оба графика растут постепенно и предсказуемо.



### 2.3 Обратно отсортированные массивы

![reversed](reversed.png)

Из гафика видно:
На обратно отсортированных данных Quick Sort хуже. Видно резкие скачки времени. IntroSort устойчив и показывает ровное, предсказуемое поведение, оставаясь быстрее на всех размерах массива.



## 3. Общий вывод

- Гибридная сортировка работает лучше на сложных массивах, например обратно отсортированных и почти отсортированных
- QuickSort хорошо работает на случайных массивах, но начинает сильно проигрывать, когда элементы  отсортированы или почти отсортированы
- IntroSort остаётся более надёжным алгоритмом: он показывает ровную работу без резких скачков, и его поведение легче предсказать

 intro_sort почти всегда работает быстрее, чем quick_sort.
QuickSort хорошо ведёт себя на случайных массивах, но проигрывает на неудобных данных, тогда как intro_sort остаётся стабильным и быстрым во всех трёх вариантах

